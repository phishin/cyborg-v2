// /stores/userSavedLogos.jsimport { defineStore } from 'pinia'import { ref, computed } from 'vue'import { useNuxtApp } from '#app'import {    getFirestore,    collection,    query,    where,    getDocs,    onSnapshot,    doc,    deleteDoc} from 'firebase/firestore'export const useUserSavedStore = defineStore('userSaved', () => {    const savedLogos = ref([])    const isLoading = ref(false)    const savedLogoCount = computed(() => savedLogos.value.length)    function _getCollectionRef() {        const { $firebaseApp } = useNuxtApp()        const db = getFirestore($firebaseApp)        return collection(db, 'logos')    }    function _getDocRef(id) {        const { $firebaseApp } = useNuxtApp()        const db = getFirestore($firebaseApp)        return doc(db, 'logos', id)    }    /** Fetch once from Firestore */    async function fetchSavedLogos(userId) {        isLoading.value = true        try {            const colRef = _getCollectionRef()            const q = query(colRef, where('userId', '==', userId))            const snap = await getDocs(q)            savedLogos.value = snap.docs.map(doc => ({                id: doc.id,                ...doc.data()            }))        } finally {            isLoading.value = false        }    }    /** Real-time subscription (optional) */    function subscribeSavedLogos(userId) {        const colRef = _getCollectionRef()        const q = query(colRef, where('userId', '==', userId))        return onSnapshot(q, snap => {            savedLogos.value = snap.docs.map(doc => ({                id: doc.id,                ...doc.data()            }))        })    }    /** Delete a single logo by id (optimistic update) */    async function deleteSavedLogo(id) {        const idx = savedLogos.value.findIndex(l => l.id === id)        const prev = idx !== -1 ? savedLogos.value[idx] : null        if (idx !== -1) savedLogos.value.splice(idx, 1)        try {            await deleteDoc(_getDocRef(id))        } catch (err) {            if (idx !== -1 && prev) savedLogos.value.splice(idx, 0, prev)            throw err        }    }    /** Optional: delete all user logos (batch sequential) */    async function deleteAllSavedLogos() {        const ids = savedLogos.value.map(l => l.id)        const prev = [...savedLogos.value]        savedLogos.value = []        try {            for (const id of ids) {                await deleteDoc(_getDocRef(id))            }        } catch (err) {            savedLogos.value = prev            throw err        }    }    return {        // state        savedLogos,        isLoading,        // getters        savedLogoCount,        // actions        fetchSavedLogos,        subscribeSavedLogos,        deleteSavedLogo,        deleteAllSavedLogos    }})